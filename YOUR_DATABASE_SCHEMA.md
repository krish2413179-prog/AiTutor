# Your Existing Database Schema

## âœ… What You Already Have

### `public.chats` Table
```sql
CREATE TABLE public.chats (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  wallet_address TEXT REFERENCES public.profiles(wallet_address) ON DELETE CASCADE NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  tokens INT DEFAULT 0
);

CREATE INDEX chats_wallet_address_idx ON public.chats (wallet_address);
ALTER TABLE public.chats ENABLE ROW LEVEL SECURITY;
```

**Purpose**: Stores all chat messages between users and the AI

**Fields**:
- `id` - Auto-incrementing unique identifier
- `created_at` - When the message was sent
- `wallet_address` - Links to the user's Solana wallet
- `role` - Who sent it: 'user', 'assistant', or 'system'
- `content` - The actual message text
- `tokens` - OpenAI token count (for cost tracking)

## â³ What You Need to Create

### `public.profiles` Table

You need this table because `chats` references it. Run this SQL:

```sql
CREATE TABLE public.profiles (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  wallet_address TEXT UNIQUE NOT NULL,
  system_prompt TEXT DEFAULT 'You are Sovereign, a personalized AI tutor.',
  level TEXT DEFAULT 'Beginner',
  topics_mastered TEXT[] DEFAULT '{}',
  last_hash TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE INDEX profiles_wallet_address_idx ON public.profiles (wallet_address);
```

**Purpose**: Stores user profiles and learning progress

**Fields**:
- `id` - Unique profile identifier
- `wallet_address` - User's Solana wallet (primary identifier)
- `system_prompt` - AI personality/instructions for this user
- `level` - Learning level: 'Beginner', 'Intermediate', 'Advanced'
- `topics_mastered` - Array of topics the user has learned
- `last_hash` - SHA-256 hash of knowledge state (for blockchain verification)
- `created_at` - When profile was created
- `updated_at` - Last profile update

## How They Work Together

```
User Connects Wallet (27sh...nqA3)
         â†“
App checks profiles table
         â†“
   Profile exists?
    â†™         â†˜
  YES         NO
   â†“           â†“
Load it    Create new profile
   â†“           â†“
   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â†“
User sends message
         â†“
Save to chats table with wallet_address
         â†“
Send to Make.com webhook
         â†“
AI responds
         â†“
Save AI response to chats table
         â†“
Display in chat interface
```

## Database Relationships

```
profiles (1) â†â”€â”€â”€â”€ (many) chats
    â†‘
    â”‚
wallet_address is the foreign key
```

- One profile can have many chat messages
- If profile is deleted, all chats are deleted (CASCADE)
- wallet_address links them together

## Row Level Security (RLS)

Your `chats` table has RLS enabled. For development, you might want to add policies:

```sql
-- Allow users to read their own chats
CREATE POLICY "Users can view own chats"
  ON public.chats FOR SELECT
  USING (wallet_address = current_setting('request.jwt.claims')::json->>'wallet_address');

-- Allow users to insert their own chats
CREATE POLICY "Users can insert own chats"
  ON public.chats FOR INSERT
  WITH CHECK (wallet_address = current_setting('request.jwt.claims')::json->>'wallet_address');
```

Or for development, disable RLS temporarily:
```sql
ALTER TABLE public.chats DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles DISABLE ROW LEVEL SECURITY;
```

## Verify Your Setup

Run this to check both tables exist:

```sql
SELECT 
    t.table_name,
    COUNT(c.column_name) as column_count,
    string_agg(c.column_name, ', ' ORDER BY c.ordinal_position) as columns
FROM information_schema.tables t
LEFT JOIN information_schema.columns c 
    ON t.table_name = c.table_name 
    AND t.table_schema = c.table_schema
WHERE t.table_schema = 'public' 
AND t.table_name IN ('profiles', 'chats')
GROUP BY t.table_name
ORDER BY t.table_name;
```

Expected output:
```
table_name | column_count | columns
-----------+--------------+------------------------------------------
chats      | 6            | id, created_at, wallet_address, role, content, tokens
profiles   | 8            | id, wallet_address, system_prompt, level, topics_mastered, last_hash, created_at, updated_at
```

## Sample Data

After connecting your wallet and minting, you should see:

**profiles table**:
```
wallet_address: 27sh189H11aUeKzsj9S7G99cSJF1ZPngPiTNJ5NCnqA3
level: Beginner
system_prompt: You are Sovereign, a personalized AI tutor.
topics_mastered: {}
```

**chats table** (after sending a message):
```
wallet_address: 27sh189H11aUeKzsj9S7G99cSJF1ZPngPiTNJ5NCnqA3
role: user
content: Hello, how are you?
tokens: 0
```

---

Your database structure is perfect for a Web3 AI tutor! ðŸŽ“
